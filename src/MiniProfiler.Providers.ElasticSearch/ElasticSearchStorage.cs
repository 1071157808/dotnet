using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Elasticsearch.Net;
using Nest;

namespace StackExchange.Profiling.Storage
{
    /// <summary>
    /// Understands how to store a <see cref="MiniProfiler"/> to a ElasticSearch database.
    /// </summary>
    public class ElasticsearchStorage : IAsyncStorage, IElasticstorageConnectable
    {
        /// <summary>
        /// The index name to store profilers in.
        /// </summary>
        public string IndexName { get; } = "miniprofiler";
        private string ConnectionString { get; }

        private ElasticClient _client;

        private ElasticClient Client
        {
            get
            {
                if (_client == null)
                {
                    using (var settings = new ConnectionSettings(new Uri(ConnectionString))
                                        .DefaultIndex(IndexName.ToLowerInvariant())
                                        .ThrowExceptions())
                    {
                        //settings.EnableDebugMode(); // Activate when need to see query generated by NEST. (result.DebugInformation)
                        _client = new ElasticClient(settings);
                    }
                }
                return _client;
            }
        }

        /// <summary>
        /// Returns a new <see cref="ElasticsearchStorage"/> based on a connection URL.
        /// </summary>
        /// <param name="connectionString">The connection string to connect to, e.g. "http://localhost:9200".</param>
        public ElasticsearchStorage(string connectionString) => ConnectionString = connectionString;

        /// <summary>
        /// Returns a new <see cref="ElasticsearchStorage"/> based on a connection URL.
        /// </summary>
        /// <param name="connectionString">The connection string to connect to, e.g. "http://localhost:9200".</param>
        /// <param name="miniProfilerIndexName">The index name to use for storage.</param>
        public ElasticsearchStorage(string connectionString, string miniProfilerIndexName) : this(connectionString)
            => IndexName = miniProfilerIndexName;

        /// <summary>
        /// Saves 'profiler' to a database under its <see cref="MiniProfiler.Id"/>.
        /// </summary>
        /// <param name="profiler">The <see cref="MiniProfiler"/> to save.</param>
        public void Save(MiniProfiler profiler)
        {
            Client.Index(profiler, i => i.Index(IndexName).Id(profiler.Id).Refresh(Refresh.True));
        }

        /// <summary>
        /// Asynchronously saves 'profiler' to a database under its <see cref="MiniProfiler.Id"/>.
        /// </summary>
        /// <param name="profiler">The <see cref="MiniProfiler"/> to save.</param>
        public Task SaveAsync(MiniProfiler profiler)
        {
            return Client.IndexAsync(profiler, i => i.Index(IndexName).Id(profiler.Id).Refresh(Refresh.True));
        }

        /// <summary>
        /// Returns the MiniProfiler identified by 'id' from the database or null when no MiniProfiler exists under that 'id'.
        /// </summary>
        /// <param name="id">The profiler ID to load.</param>
        /// <returns>The loaded <see cref="MiniProfiler"/>.</returns>
        public MiniProfiler Load(Guid id)
        {
            var find = Client.Get<MiniProfiler>(id, idx => idx.Index(IndexName));
            if (!find.IsValid)
            {
                Console.WriteLine($"WARN: Problem to Load data. Message: {find.DebugInformation}");
                return null;
            }
            return find.Source;
        }

        /// <summary>
        /// Asynchronously returns the MiniProfiler identified by 'id' from the database or null when no MiniProfiler exists under that 'id'.
        /// </summary>
        /// <param name="id">The profiler ID to load.</param>
        /// <returns>The loaded <see cref="MiniProfiler"/>.</returns>
        public async Task<MiniProfiler> LoadAsync(Guid id)
        {
            var find = await Client.GetAsync<MiniProfiler>(id, idx => idx.Index(IndexName)).ConfigureAwait(false);
            if (!find.IsValid)
            {
                Console.WriteLine($"WARN: Problem to Load data. Message: {find.DebugInformation}");
                return null;
            }
            return find.Source;
        }

        /// <summary>
        /// Sets a particular profiler session so it is considered "unviewed"  
        /// </summary>
        /// <param name="user">The user to set this profiler ID as unviewed for.</param>
        /// <param name="id">The profiler ID to set unviewed.</param>
        public void SetUnviewed(string user, Guid id)
        {
            Client.UpdateByQuery<MiniProfiler>(d => GetViewdToggleQuery(d, user, id, false));
        }

        /// <summary>
        /// Asynchronously sets a particular profiler session so it is considered "unviewed"  
        /// </summary>
        /// <param name="user">The user to set this profiler ID as unviewed for.</param>
        /// <param name="id">The profiler ID to set unviewed.</param>
        public Task SetUnviewedAsync(string user, Guid id)
        {
            return Client.UpdateByQueryAsync<MiniProfiler>(d => GetViewdToggleQuery(d, user, id, false));
        }

        /// <summary>
        /// Sets a particular profiler session to "viewed"
        /// </summary>
        /// <param name="user">The user to set this profiler ID as viewed for.</param>
        /// <param name="id">The profiler ID to set viewed.</param>
        public void SetViewed(string user, Guid id)
        {
            Client.UpdateByQuery<MiniProfiler>(d => GetViewdToggleQuery(d, user, id, true));
        }

        /// <summary>
        /// Asynchronously sets a particular profiler session to "viewed"
        /// </summary>
        /// <param name="user">The user to set this profiler ID as viewed for.</param>
        /// <param name="id">The profiler ID to set viewed.</param>
        public Task SetViewedAsync(string user, Guid id)
        {
            return Client.UpdateByQueryAsync<MiniProfiler>(d => GetViewdToggleQuery(d, user, id, true));
        }

        private UpdateByQueryDescriptor<MiniProfiler> GetViewdToggleQuery(
            UpdateByQueryDescriptor<MiniProfiler> descriptor,
            string user,
            Guid id,
            bool hasViewed
        ) =>
                descriptor.Query(q => q
                    .Match(m => m
                        .Field(f => f.User)
                        .Query(user)
                    ) && q
                    .Match(m => m
                       .Field(f => f.Id)
                      .Query(id.ToString())
                    )
                )
                .Script(hasViewed ? "ctx._source.hasUserViewed = true" : "ctx._source.hasUserViewed = false")
                .Conflicts(Conflicts.Proceed)
                .Refresh(true);

        /// <summary>
        /// Returns a list of <see cref="MiniProfiler.Id"/>s that haven't been seen by <paramref name="user"/>.
        /// </summary>
        /// <param name="user">User identified by the current <c>MiniProfilerOptions.UserProvider</c>.</param>
        /// <returns>The list of keys for the supplied user</returns>
        public List<Guid> GetUnviewedIds(string user)
        {
            var result = Client.Search<MiniProfiler>(_ => GetUnviewedIdsQuery(user));
            if (!result.IsValid) return new List<Guid>();
            return result.Documents.Select(d => d.Id).ToList();
        }

        /// <summary>
        /// Asynchronously returns a list of <see cref="MiniProfiler.Id"/>s that haven't been seen by <paramref name="user"/>.
        /// </summary>
        /// <param name="user">User identified by the current <c>MiniProfilerOptions.UserProvider</c>.</param>
        /// <returns>The list of keys for the supplied user</returns>
        public async Task<List<Guid>> GetUnviewedIdsAsync(string user)
        {
            var result = await Client.SearchAsync<MiniProfiler>(_ => GetUnviewedIdsQuery(user)).ConfigureAwait(false);
            if (!result.IsValid) return new List<Guid>();
            return result.Documents.Select(d => d.Id).ToList();
        }

        private static SearchDescriptor<MiniProfiler> GetUnviewedIdsQuery(string user) =>
            new SearchDescriptor<MiniProfiler>().Query(q => q
                .Match(m => m
                    .Field(f => f.User)
                    .Query(user)
                ) && q
                .Match(m => m
                    .Field(f => f.HasUserViewed)
                    .Query("false")
                ));

        /// <summary>
        /// Returns the MiniProfiler Ids for the given search criteria.
        /// </summary>
        /// <param name="maxResults">The max number of results.</param>
        /// <param name="start">Search window start.</param>
        /// <param name="finish">Search window end.</param>
        /// <param name="orderBy">Result order.</param>
        /// <returns>The list of GUID keys.</returns>
        public IEnumerable<Guid> List(int maxResults, DateTime? start = null, DateTime? finish = null, ListResultsOrder orderBy = ListResultsOrder.Descending)
        {
            var result = Client.Search<MiniProfiler>(_ => GetListQuery(maxResults, start, finish, orderBy));
            return result.Documents.Select(d => d.Id);
        }

        /// <summary>
        /// Asynchronously returns the MiniProfiler Ids for the given search criteria.
        /// </summary>
        /// <param name="maxResults">The max number of results.</param>
        /// <param name="start">Search window start.</param>
        /// <param name="finish">Search window end.</param>
        /// <param name="orderBy">Result order.</param>
        /// <returns>The list of GUID keys.</returns>
        public async Task<IEnumerable<Guid>> ListAsync(int maxResults, DateTime? start = null, DateTime? finish = null, ListResultsOrder orderBy = ListResultsOrder.Descending)
        {
            var result = await Client.SearchAsync<MiniProfiler>(_ => GetListQuery(maxResults, start, finish, orderBy)).ConfigureAwait(false);
            return result.Documents.Select(d => d.Id);
        }

        private SearchDescriptor<MiniProfiler> GetListQuery(int maxResults, DateTime? start = null, DateTime? finish = null, ListResultsOrder orderBy = ListResultsOrder.Descending)
        {
            var query = new SearchDescriptor<MiniProfiler>();
            if (start != null && finish != null)
            {
                var startFilter = new QueryContainerDescriptor<MiniProfiler>().DateRange(r => r.Field(f => f.Started).GreaterThan(start));
                var endFilter = new QueryContainerDescriptor<MiniProfiler>().DateRange(r => r.Field(f => f.Started).LessThan(finish));
                query.Query(_ => startFilter && endFilter);
            }
            else if (finish == null && start != null)
            {
                var startFilter = new QueryContainerDescriptor<MiniProfiler>().DateRange(r => r.Field(f => f.Started).GreaterThan(start));
                query.Query(_ => startFilter);
            }
            return query.Index(IndexName)
               .From(0)
               .Size(maxResults)
               .Sort(s =>
               {
                   if (orderBy == ListResultsOrder.Descending)
                       return s.Descending(f => f.Started);
                   else
                       return s.Ascending(f => f.Started);
               });
        }

        /// <summary>
        /// Returns a client connection to Elastic.
        /// </summary>

        ElasticClient IElasticstorageConnectable.GetClient() => Client;
    }

    /// <summary>
    /// Interface for accessing the <see cref="ElasticsearchStorage"/>'s connection, for testing.
    /// </summary>
    public interface IElasticstorageConnectable
    {
        /// <summary>
        /// Gets the connection for a <see cref="IDatabaseStorageConnectable"/> for testing.
        /// </summary>
        /// <returns>The connection for this storage.</returns>
        ElasticClient GetClient();
    }
}
